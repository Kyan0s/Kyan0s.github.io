## Unity 逆向学习记录 - WebGL

<br>

### 0. 一些废话

虽然一直叫嚣着 “我要学游戏开发” 什么的，然而拜拖延症所赐也就是叫嚣罢了。万万没想到生活所迫这玩意重新搞起来了 doge

<br>

### 1. 食材

今天的目标是分析 assets 相关文件。之前都是直奔 Assembly-CSharp.dll 去的，现在想来这也大抵没错。但教程中提到的 WebGL 编译使用了 il2cpp，所以需要先从还原 Assembly-CSharp.dll （或者说至少拿到一个函数声明表？）开始。

食材为从 Unity Learn 上随便抓的一个游戏 [2D Platformer](https://assetstore.unity.com/packages/templates/platformer-microgame-151055) 。如果时光能倒流，我选择以分析 Hello World 开始。 QAQ

教程中该游戏大概长这样：

![](https://connect-prd-cdn.unity.com/20190313/learn/images/ef3bf79d-def0-41d8-bd08-a842cc92c0e2_PlatformerTrails.png)

目标平台是用的是教程默认的 WebGL，所生成目录结构如下：

```shel
192:WebGL Builds Kyan0s$ tree
.
├── Build
│   ├── WebGL Builds.data.gz
│   ├── WebGL Builds.framework.js.gz
│   ├── WebGL Builds.loader.js
│   └── WebGL Builds.wasm.gz
├── GUID.txt
├── ProjectVersion.txt
├── TemplateData
│   ├── favicon.ico
│   ├── fullscreen-button.png
│   ├── progress-bar-empty-dark.png
│   ├── progress-bar-empty-light.png
│   ├── progress-bar-full-dark.png
│   ├── progress-bar-full-light.png
│   ├── style.css
│   ├── unity-logo-dark.png
│   ├── unity-logo-light.png
│   └── webgl-logo.png
├── dependencies.txt
└── index.html
```

根据粗浅搜索，剥离（我个人理解）的二进制文件为 `.wasm`，而函数名等需要从作为资源文件的 `.data` 中摘出。结合 `.wasm` 与从资源文件中提取出的 `global-metadata.dat` ，Il2CppDumper 能够还原函数声明等，并据此辅助对 `.wasm` 的逆向。

AssetStudio 能够完成提取 `global-metadata.dat` 这一工作。但一开始我只知道要用这个软件却不知道应具体使用其何种功能，于是先折腾了下其在 MacOS 上的平替：由 Python 实现的 `UnityPy`。

<br>

### 2. 围观 UnityPy

虽然目前来看 UnityPy 相比 AssetStudio 还是 Bug 多了一点，但清楚的文档和使用示例还是蛮适合纯零基础小白入坑。

首先围观了下资源文件中都包含哪些类型的资源：

```python
{
    'Animator', 
    'RectTransform', 
    ...,
    'MonoBehaviour', 
    'DelayedCallManager', 
    'Material', 
    'MonoScript', 
    'AudioSource', 
    'Grid', 
    'Transform', 
    'AnimatorController', 
    'CircleCollider2D', 
    'Mesh', 
    'MonoManager', 
    'SpriteRenderer'
}
```

在各式解包文章中经常被提到的似乎是 `MonoScript` 和 `MonoBehaviour`，后续也着重分析了这两种类型。通过魔改 UnityPy 提供的 [extractor.py](https://github.com/K0lb3/UnityPy/blob/master/UnityPy/tools/extractor.py) 脚本，记录 `MonoBehaviour` 及 `MonoScript` 的相关信息：

```json
{
    "m_AssemblyName": "Unity.TextMeshPro.dll",
    "m_ClassName": "TMP_FontAsset",
    "m_ExecutionOrder": 0,
    "m_Namespace": "TMPro",
    "platform": "WebGL",
    "name": "TMP_FontAsset"
}
```

然而并不是所有的 `MonoBehaviour` 都能 dump 出相关信息。下述 `.bin` 文件即为分析失败的对象；结合游戏截图和文件名推测，分析失败的对象似乎反而更为重要：

```shell
192:MonoBehaviour Kyan0s$ ls | cat
Default_Style_Sheet.json
EmojiOne.json
GameSkin.json
LiberationSans_SDF.json
MidgroundFiller.bin
ShortBuilding.bin
TMP_Settings.json
TallBuilding.bin
TileFloatingLeftEdge.bin
TileFloatingRightEdge.bin
TileFloatingTileMiddle.bin
TileGround.bin
TileGroundDark.bin
TileGroundTop.bin
cloud.bin
fence.bin
hillside.bin
house.bin
midground.bin
mountains.bin
plant.bin
tree.bin
```
<br>

### 3. 分析的正途

上文分析失败的 `MonoBehaviour` 被 AssetStudio 好好地分析出来了，虽然乍一看可读性不如  UnityPy：

![](https://raw.githubusercontent.com/Kyan0s/Kyan0s.github.io/main/assets/img/assets-cloud.png)

但这不妨碍通过 `File -> Extract file` 提取得到 `global-metadata.dat`。然后倒入 `.wasm`，加以搅拌后喂给 Il2CppDumper，于是期望发生的一切都发生了（？）。得到的 `dump.cs` 画风如下：

```c
// Namespace: Mono.Globalization.Unicode
internal class Level2Map // TypeDefIndex: 33
{
	// Fields
	public byte Source; // 0x8
	public byte Replace; // 0x9

	// Methods

	// RVA: 0x83E Offset: 0x83E VA: 0x83E
	public void .ctor(byte source, byte replace) { }
}
```

<br>

### 4. 大概类似于符号表恢复

新版本的 Il2CppDumper 会将函数声明等保存为 json 文件，然后提供了在 IDA / Ghidra 等工具中使用该 json 文件的脚本，具体操作根据 [教程](https://noob3xploiter.medium.com/hacking-and-reverse-engineering-il2cpp-games-with-ghidra-5cee894024f2)：

> To start reverse engineering, open up ghidra and load the original gameassembly.dll in to it. Then, import the il2cpp\_ghidra.h by going to File>Parse C Code and add the il2cpp\_ghidra.h . Next, we need to run a script given to us by il2cppdumper called ghidra\_with\_struct.py . Click on the script tab, add the directory of il2cppdumper to your script directories and run the ghidra\_with\_struct script. In there, select the script.json file generated by il2cppdumper.

照做之后画风如下：

![](https://raw.githubusercontent.com/Kyan0s/Kyan0s.github.io/main/assets/img/ghidra_wrong_wasm_func.png)

<br>

心情平复下来后，由于非常好奇这些脚本究竟如何工作（毕竟如果将函数参数和返回类型作为特征一定会找到很多相似函数），去围观了下脚本源代码：

```python
baseAddress = currentProgram.getImageBase()

def get_addr(addr):
	return baseAddress.add(addr)
	
if "ScriptMethod" in data and "ScriptMethod" in processFields:
	scriptMethods = data["ScriptMethod"]
	for scriptMethod in scriptMethods:
		addr = get_addr(scriptMethod["Address"])
		sig = scriptMethod["Signature"][:-1].encode("utf-8")
		name = scriptMethod["Name"].encode("utf-8")
		set_sig(addr, name, sig)
```

再看 `script.json` 中的地址偏移：

```json
"ScriptMethod": [
    {
      "Address": 2747,
      "Name": "Locale$$GetText",
      "Signature": "System_String_o* Locale__GetText (System_String_o* msg, const MethodInfo* method);",
      "TypeSignature": "iii"
    },
    {
      "Address": 2026,
      "Name": "Locale$$GetText",
      "Signature": "System_String_o* Locale__GetText (System_String_o* fmt, System_Object_array* args, const MethodInfo* method);",
      "TypeSignature": "iiii"
    },
    ...
]
```
这个 `Address` 比起地址看上去更像 index.

<br>

### 5. 地址修复

根据 [浅谈逆向 Unity WebGL Il2Cpp 中 WebAssembly 函数的方法](https://www.cnblogs.com/algonote/p/15596459.html)，出于安全考虑 wasm 通过形如 `dynCall_iiii` 的函数来实现动态调用：对于具有同样参数数量及类型的函数，通过查询其在该特征函数表中的编号（即上文提到的 `Address`）来获取其地址并最终进行调用。作者同样给出了自动进行地址修复的脚本 `ghidra_wasm.py`。

然而执行脚本该脚本所依赖的、ghidra-wasm-plugin 插件中自带的脚本 `analyze_dyncalls.py` 时，出现异常：

```python
def renameDyncalls(calltype):
    offset, mask = dynCalls.get(calltype, (0, 0))
    nullFunc = getTableFunction(offset)
    nullFunc.setName("nullFuncPtr_" + calltype, SourceType.USER_DEFINED)
    monitor.setMessage("Renaming " + calltype + " functions")
    monitor.initialize(mask)
    for i in range(mask+1):
        monitor.setProgress(i)
        func = getTableFunction(offset + i)
        name = "func_" + calltype + "_%d" % i
        if func.name.startswith("unnamed_function_"):
            func.setName(name, SourceType.ANALYSIS)
        
        # AttributeError: 'ghidra.program.database.symbol.SymbolManager' object has no attribute 'createSymbol
        currentProgram.symbolTable.createSymbol(func.entryPoint, name, dynCallNamespace, SourceType.USER_DEFINED)
```

我所使用的 Ghidra 版本为 `10.1.2`。查询 [文档](https://ghidra.re/ghidra_docs/api/ghidra/program/model/symbol/SymbolTable.html) 发现 `SymbolTable` 中已无对应函数。尝试将其修改为增加标签（Label）的函数，执行成功：

```python
# currentProgram.symbolTable.createSymbol(func.entryPoint, name, dynCallNamespace, SourceType.USER_DEFINED)
currentProgram.symbolTable.createLabel(func.entryPoint, name, dynCallNamespace, SourceType.USER_DEFINED)
```
<br>

为确认地址修复是否正确，尝试比较一个简单函数及其反编译结果。源代码：

```c
namespace Platformer.Gameplay
{
    public class EnemyDeath : Simulation.Event<EnemyDeath>
    {
        public EnemyController enemy;
        public override void Execute()
        {
            enemy._collider.enabled = false;
            enemy.control.enabled = false;
            if (enemy._audio && enemy.ouch)
                enemy._audio.PlayOneShot(enemy.ouch);
        }
    }
}
```
反编译结果：

```c
void Platformer.Gameplay.EnemyDeath$$Execute(int param1,undefined4 param2)
{
  int iVar1;
  undefined4 uVar2;
  
  if (cRam002c2799 == '\0') {
    func_vi_9925(&UnityEngine.Object_TypeInfo);
    cRam002c2799 = '\x01';
  }
  UnityEngine.Behaviour$$set_enabled(*(undefined4 *)(*(int *)(param1 + 0xc) + 0x1c),0,0);
  UnityEngine.Behaviour$$set_enabled(*(undefined4 *)(*(int *)(param1 + 0xc) + 0x18),0,0);
  uVar2 = *(undefined4 *)(*(int *)(param1 + 0xc) + 0x20);
  if (((*(ushort *)(UnityEngine.Object_TypeInfo + 0xba) & 0x400) != 0) &&
     (*(int *)(UnityEngine.Object_TypeInfo + 0x74) == 0)) {
    func_vi_9938(UnityEngine.Object_TypeInfo);
  }
  iVar1 = UnityEngine.Object$$op_Implicit(uVar2,0);
  if (iVar1 != 0) {
    uVar2 = *(undefined4 *)(*(int *)(param1 + 0xc) + 0x10);
    if (((*(ushort *)(UnityEngine.Object_TypeInfo + 0xba) & 0x400) != 0) &&
       (*(int *)(UnityEngine.Object_TypeInfo + 0x74) == 0)) {
      func_vi_9938(UnityEngine.Object_TypeInfo);
    }
    iVar1 = UnityEngine.Object$$op_Implicit(uVar2,0);
    if (iVar1 != 0) {
      UnityEngine.AudioSource$$PlayOneShot
                (*(undefined4 *)(*(int *)(param1 + 0xc) + 0x20),
                 *(undefined4 *)(*(int *)(param1 + 0xc) + 0x10),0);
    }
  }
  return;
}
```
虽然看上去有点好乱，但从对 `PlayOneShot` 的调用来看修复应该无误。

<br>

